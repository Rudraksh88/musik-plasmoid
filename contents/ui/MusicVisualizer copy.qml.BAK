import QtQuick 2.15
import QtQuick.Layouts 1.15
import Qt5Compat.GraphicalEffects
import org.kde.plasma.components as PlasmaComponents3
import org.kde.kirigami as Kirigami

Item {
    id: root

    property bool isPlaying: false
    property color accentColor: "#1d99f3"
    property bool showPeaks: true
    property int barCount: 32
    property real intensity: 1.0

    property var barHeights: new Array(barCount).fill(0)
    property var peakHeights: new Array(barCount).fill(0)
    property var targetHeights: new Array(barCount).fill(0)
    property real time: 0

    readonly property real smoothing: 0.85
    readonly property real peakFallSpeed: 0.02
    readonly property real minHeight: 0.05
    readonly property real barSpacing: 2

    // Generate harmonious secondary color
    readonly property color secondaryColor: {
        const hue = accentColor.hsvHue
        const sat = accentColor.hsvSaturation
        const val = accentColor.hsvValue

        return Qt.hsva(
            (hue + 0.15) % 1.0,  // +54 degrees (0.15 in normalized hue)
            sat * 1.1,           // Slightly boost saturation
            val * 0.95,          // Slightly reduce brightness
            1.0
        )
    }

    Item {
        id: paddedContainer
        anchors.fill: parent
        anchors.margins: -100

        Item {
            id: visualizerContainer
            anchors.fill: parent
            anchors.margins: 32

            Canvas {
                id: canvas
                anchors.fill: parent
                renderStrategy: Canvas.Cooperative
                visible: false

                Timer {
                    id: animTimer
                    interval: 16
                    repeat: true
                    running: root.isPlaying
                    onTriggered: {
                        time += interval / 1000
                        updateBars()
                        canvas.requestPaint()
                    }
                }

                onPaint: {
                    var ctx = getContext("2d")
                    var w = width
                    var h = height

                    ctx.clearRect(0, 0, w, h)

                    var barWidth = (w - (barSpacing * (barCount - 1))) / barCount

                    // Create gradient focused more towards the peak
                    var gradient = ctx.createLinearGradient(0, h, 0, h * 0.2) // Compress gradient to top 30%
                    gradient.addColorStop(0, Qt.rgba(secondaryColor.r, secondaryColor.g, secondaryColor.b, 0.1))
                    gradient.addColorStop(0.1, Qt.rgba(
                        (accentColor.r * 0.7 + secondaryColor.r * 0.3),
                        (accentColor.g * 0.7 + secondaryColor.g * 0.3),
                        (accentColor.b * 0.7 + secondaryColor.b * 0.3),
                        1
                    ))
                    gradient.addColorStop(1, Qt.rgba(accentColor.r, accentColor.g, accentColor.b, 0.8))

                    // Draw bars
                    for (var i = 0; i < barCount; i++) {
                        var x = i * (barWidth + barSpacing)
                        var barHeight = barHeights[i] * h

                        // Draw overlapping rectangles with the gradient
                        for (var j = 0; j < 3; j++) {
                            ctx.fillStyle = gradient
                            var expandedWidth = barWidth * (1.8 + j * 0.4)
                            ctx.fillRect(x - expandedWidth/3, h - barHeight, expandedWidth, barHeight)
                        }
                    }
                }
            }

            // Single Gaussian blur for better clarity
            GaussianBlur {
                anchors.fill: canvas
                source: canvas
                radius: 64
                samples: 88
                cached: true
                opacity: 1  // Slightly reduce opacity for more transparency
            }
        }
    }

    function updateBars() {
        for (var i = 0; i < barCount; i++) {
            var phase = (i / barCount) * Math.PI * 2
            var wave = (Math.sin(time * 2.5 + phase) + 1) / 2
            var wave2 = (Math.sin(time * 1.7 + phase * 2) + 1) / 2
            var wave3 = (Math.sin(time * 1.2 + phase * 3) + 1) / 2

            targetHeights[i] = minHeight + (wave * 0.3 + wave2 * 0.2 + wave3 * 0.15) * intensity
            barHeights[i] = barHeights[i] * smoothing + targetHeights[i] * (1 - smoothing)
        }
    }

    onIsPlayingChanged: {
        if (isPlaying) {
            time = 0
        } else {
            for (var i = 0; i < barCount; i++) {
                targetHeights[i] = minHeight
            }
        }
    }
}